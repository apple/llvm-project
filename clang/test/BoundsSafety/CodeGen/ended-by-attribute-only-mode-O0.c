// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5

// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -x c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x c++ -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x objective-c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x objective-c++ -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

#ifdef __cplusplus
extern "C" {
#endif

// CHECK-LABEL: define dso_local i32 @fn_deref(
// CHECK-SAME: ptr noundef [[P:%.*]], ptr noundef [[END:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[END_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store ptr [[END]], ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int fn_deref(int *__ended_by(end) p, int *end) {
  return *p;
}

// CHECK-LABEL: define dso_local i32 @fn_subscript(
// CHECK-SAME: ptr noundef [[P:%.*]], ptr noundef [[END:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[END_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store ptr [[END]], ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP2]], 1
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[SUB]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP0]], i64 [[IDXPROM]]
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret i32 [[TMP3]]
//
int fn_subscript(int *__ended_by(end) p, int *end) {
  return p[*end - 1];
}

// CHECK-LABEL: define dso_local ptr @fn_assign(
// CHECK-SAME: ptr noundef [[P:%.*]], ptr noundef [[END:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[END_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store ptr [[END]], ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP0]], i64 -42
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[END_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 42
// CHECK-NEXT:    store ptr [[ADD_PTR1]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    ret ptr [[TMP2]]
//
int *fn_assign(int *__ended_by(end) p, int *end) {
  end = end - 42;
  p = p + 42;
  return p;
}

struct bar {
  int *__ended_by(end) q;
  int *end;
};

// CHECK-LABEL: define dso_local i32 @struct_deref(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int struct_deref(struct bar *b) {
  return *b->q;
}

// CHECK-LABEL: define dso_local i32 @struct_subscript(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[END:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP2]], i32 0, i32 1
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[END]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP4]], 1
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[SUB]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 [[IDXPROM]]
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret i32 [[TMP5]]
//
int struct_subscript(struct bar *b) {
  return b->q[*b->end - 1];
}

// CHECK-LABEL: define dso_local void @struct_assign(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[END:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[END]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 -42
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[END1:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP2]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[END1]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP3]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[ADD_PTR2:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i64 42
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q3:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP5]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[ADD_PTR2]], ptr [[Q3]], align 8
// CHECK-NEXT:    ret void
//
void struct_assign(struct bar *b) {
  b->end = b->end - 42;
  b->q = b->q + 42;
}

#ifdef __cplusplus
}
#endif
